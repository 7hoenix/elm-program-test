[{"name":"ProgramTest","comment":" A `ProgramTest` simulates the execution of an Elm program\nenabling you write high-level tests for your program.\n(High-level tests are valuable in that they provide extremely robust test coverage\nin the case of drastic refactorings of your application architecture,\nand writing high-level tests helps you focus on the needs and behaviors of your end-users.)\n\nThis module allows you to interact with your program by simulating\nDOM events (see [\"Simulating user input\"](#simulating-user-input)) and\nexternal events (see [\"Simulating HTTP responses\"](#simulating-http-responses),\n[\"Simulating time\"](#simulating-time),\nand [\"Simulating ports\"](#simulating-ports)).\n\nAfter simulating a series of events, you can then check assertions about\nthe currently rendered state of your program (see [\"Final assertions\"](#final-assertions)).\n\n\n# Creating\n\n@docs ProgramTest, start\n\n\n## Creating program definitions\n\nA `ProgramDefinition` (required to create a `ProgramTest` with [`start`](#start))\ncan be created with one of the following functions that parallel\nthe functions in `elm/browser`'s `Browser` module.\n\n@docs createSandbox, createElement, createDocument, createApplication\n@docs ProgramDefinition\n\n\n## Options\n\nThe following functions allow you to configure your\n`ProgramDefinition` before starting it with [`start`](#start).\n\n@docs withBaseUrl, withJsonStringFlags\n\n@docs withSimulatedEffects, SimulatedEffect, SimulatedTask\n@docs withSimulatedSubscriptions, SimulatedSub\n\n\n# Simulating user input\n\n@docs clickButton, clickLink\n@docs fillIn, fillInTextarea\n@docs check, selectOption\n@docs routeChange\n\n\n## Simulating user input (advanced)\n\n@docs simulate\n@docs within\n\n\n# Simulating external events\n\n\n## Simulating HTTP responses\n\n@docs assertHttpRequestWasMade, assertHttpRequest\n@docs simulateHttpOk, simulateHttpResponse\n\n\n## Simulating time\n\n@docs advanceTime\n\n\n## Simulating ports\n\n@docs assertAndClearOutgoingPortValues, simulateIncomingPort\n\n\n# Directly sending Msgs\n\n@docs update\n@docs simulateLastEffect\n\n\n# Final assertions\n\n@docs expectViewHas, expectView\n@docs expectLastEffect, expectModel\n@docs expectPageChange\n\n\n# Intermediate assertions\n\nThese functions can be used to make assertions on a `ProgramTest` without ending the test.\n\n@docs shouldHave, shouldNotHave, shouldHaveView\n@docs shouldHaveLastEffect\n\nTo end a `ProgramTest` without using a [final assertion](#final-assertions), use the following function:\n\n@docs done\n\n\n# Custom assertions\n\nThese functions may be useful if you are writing your own custom assertion functions.\n\n@docs fail, createFailed\n\n","unions":[{"name":"ProgramDefinition","comment":" Represents an unstarted program test.\nUse [`start`](#start) to start the program being tested.\n","args":["flags","model","msg","effect"],"cases":[]},{"name":"ProgramTest","comment":" A `ProgramTest` represents an Elm program, a current state for that program,\nand a log of any errors that have occurred while simulating interaction with the program.\n\n  - To create a `ProgramTest`, see the `create*` functions below.\n  - To advance the state of a `ProgramTest`, see [Simulating user input](#simulating-user-input), and [Directly sending Msgs](#directly-sending-msgs)\n  - To assert on the resulting state of a `ProgramTest`, see [Final assertions](#final-assertions)\n\n","args":["model","msg","effect"],"cases":[]}],"aliases":[{"name":"SimulatedEffect","comment":" This represents an effect that elm-program-test is able to simulate.\nWhen using [`withSimulatedEffects`](#withSimulatedEffects) you will provide a function that can translate\nyour program's effects into `SimulatedEffect`s.\n(If you do not use `withSimulatedEffects`,\nthen `ProgramTest` will not simulate any effects for you.)\n\nYou can create `SimulatedEffect`s using the the following modules,\nwhich parallel the modules your real program would use to create `Cmd`s and `Task`s:\n\n  - [`SimulatedEffect.Http`](SimulatedEffect-Http) (parallels `Http` from `elm/http`)\n  - [`SimulatedEffect.Cmd`](SimulatedEffect-Cmd) (parallels `Platform.Cmd` from `elm/core`)\n  - [`SimulatedEffect.Navigation`](SimulatedEffect-Navigation) (parallels `Browser.Navigation` from `elm/browser`)\n  - [`SimulatedEffect.Ports`](SimulatedEffect-Ports) (parallels the `port` keyword)\n  - [`SimulatedEffect.Task`](SimulatedEffect-Task) (parallels `Task` from `elm/core`)\n  - [`SimulatedEffect.Process`](SimulatedEffect-Process) (parallels `Process` from `elm/core`)\n\n","args":["msg"],"type":"SimulatedEffect.SimulatedEffect msg"},{"name":"SimulatedSub","comment":" This represents a subscription that elm-program-test is able to simulate.\nWhen using [`withSimulatedSubscriptions`](#withSimulatedSubscriptions) you will provide\na function that is similar to your program's `subscriptions` function but that\nreturns `SimulatedSub`s instead `Sub`s.\n(If you do not use `withSimulatedSubscriptions`,\nthen `ProgramTest` will not simulate any subscriptions for you.)\n\nYou can create `SimulatedSub`s using the the following modules:\n\n  - [`SimulatedEffect.Ports`](SimulatedEffect-Ports) (parallels the `port` keyword)\n\n","args":["msg"],"type":"SimulatedEffect.SimulatedSub msg"},{"name":"SimulatedTask","comment":" Similar to `SimulatedEffect`, but represents a `Task` instead of a `Cmd`.\n","args":["x","a"],"type":"SimulatedEffect.SimulatedTask x a"}],"values":[{"name":"advanceTime","comment":" Simulates the passing of time.\nThe `Int` parameter is the number of milliseconds to simulate.\nThis will cause any pending `Task.sleep`s to trigger if their delay has elapsed.\n\nNOTE: You must use [`withSimulatedEffects`](#withSimulatedEffects) before you call [`start`](#start) to be able to use this function.\n\n","type":"Basics.Int -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"assertAndClearOutgoingPortValues","comment":" Lets you assert on the values that have been sent to an outgoing port.\n\nThe parameters are:\n\n1.  The name of the port\n2.  A JSON decoder corresponding to the type of the port\n3.  A function that will receive the list of values sent to the port\n    since the last use of `assertAndClearOutgoingPortValues` (or since the start of the test)\n    and returns an `Expectation`\n\nFor example:\n\n    ...\n        |> assertAndClearOutgoingPortValues\n            \"saveApiTokenToLocalStorage\"\n            Json.Decode.string\n            (Expect.equal [ \"975774a26612\", \"920facb1bac0\" ])\n        |> ...\n\nNOTE: You must use [`withSimulatedEffects`](#withSimulatedEffects) before you call [`start`](#start) to be able to use this function.\n\n","type":"String.String -> Json.Decode.Decoder a -> (List.List a -> Expect.Expectation) -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"assertHttpRequest","comment":" Allows you to check the details of a pending HTTP request.\n\nSee the [\"Expectations\" section of `Test.Http`](Test-Http#expectations) for functions that might be helpful\nin create an expectation on the request.\n\nIf you only care about whether the a request was made to the correct URL, see [`assertHttpRequestWasMade`](#assertHttpRequestWasMade).\n\n    ...\n        |> assertHttpRequest \"POST\"\n            \"https://example.com/save\"\n            (.body >> Expect.equal \"\"\"{\"content\":\"updated!\"}\"\"\")\n        |> ...\n\n","type":"String.String -> String.String -> (SimulatedEffect.HttpRequest msg msg -> Expect.Expectation) -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"assertHttpRequestWasMade","comment":" A final assertion that checks whether an HTTP request to the specific url and method has been made.\n\nIf you want to check the headers or request body, see [`assertHttpRequest`](#assertHttpRequest).\n\nNOTE: You must use [`withSimulatedEffects`](#withSimulatedEffects) before you call [`start`](#start) to be able to use this function.\n\n","type":"String.String -> String.String -> ProgramTest.ProgramTest model msg effect -> Expect.Expectation"},{"name":"check","comment":" Simulates setting the value of a checkbox labeled with the given label.\n\nThe parameters are:\n\n1.  The id of the input field\n    (which must match both the `id` attribute of the target `input` element,\n    and the `for` attribute of the `label` element),\n    or `\"\"` if the `<input>` is a descendant of the `<label>`.\n\n    NOTE: After [eeue56/elm-html-test#52](https://github.com/eeue56/elm-html-test/issues/52) is resolved,\n    a future release of this package will remove this parameter.\n\n2.  The label text of the input field\n\n3.  A `Bool` indicating whether to check (`True`) or uncheck (`False`) the checkbox.\n\nNOTE: Currently, this function requires that you also provide the field id\n(which must match both the `id` attribute of the target `input` element,\nand the `for` attribute of the `label` element).\nAfter [eeue56/elm-html-test#52](https://github.com/eeue56/elm-html-test/issues/52) is resolved,\na future release of this package will remove the `fieldId` parameter.\n\nNOTE: In the future, this will be generalized to work with\naria accessibility attributes in addition to working with standard HTML label elements.\n\nIf you need more control over the finding the target element or creating the simulated event,\nsee [`simulate`](#simulate).\n\n","type":"String.String -> String.String -> Basics.Bool -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"clickButton","comment":" Simulates clicking a button.\n\nCurrently, this function will find and click a `<button>` HTML node containing the given `buttonText`.\n\nNOTE: In the future, this function will be generalized to find buttons with accessibility attributes\nmatching the given `buttonText`.\n\n","type":"String.String -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"clickLink","comment":" Simulates clicking a `<a href=\"...\">` link.\n\nThe parameters are:\n\n1.  The text of the `<a>` tag (which is the link text visible to the user).\n\n2.  The `href` of the `<a>` tag.\n\n    NOTE: After [eeue56/elm-html-test#52](https://github.com/eeue56/elm-html-test/issues/52) is resolved,\n    a future release of this package will remove the `href` parameter.\n\nNote for testing single-page apps:\nif the target `<a>` tag has an `onClick` handler,\nthen the message produced by the handler will be processed\nand the `href` will not be followed.\nNOTE: Currently this function cannot verify that the onClick handler\nsets `preventDefault`, but this will be done in the future after\n<https://github.com/eeue56/elm-html-test/issues/63> is resolved.\n\n","type":"String.String -> String.String -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"createApplication","comment":" Creates a `ProgramTest` from the parts of a `Browser.application` program.\n\nSee other `create*` functions if the program you want to test does not use `Browser.application`.\n\nIf your program has subscriptions that you want to simulate, see [`withSimulatedSubscriptions`](#withSimulatedSubscriptions).\n\n","type":"{ init : flags -> Url.Url -> () -> ( model, effect ), view : model -> Browser.Document msg, update : msg -> model -> ( model, effect ), onUrlRequest : Browser.UrlRequest -> msg, onUrlChange : Url.Url -> msg } -> ProgramTest.ProgramDefinition flags model msg effect"},{"name":"createDocument","comment":" Creates a `ProgramTest` from the parts of a `Browser.document` program.\n\nSee other `create*` functions if the program you want to test does not use `Browser.document`.\n\nIf your program has subscriptions that you want to simulate, see [`withSimulatedSubscriptions`](#withSimulatedSubscriptions).\n\n","type":"{ init : flags -> ( model, effect ), view : model -> Browser.Document msg, update : msg -> model -> ( model, effect ) } -> ProgramTest.ProgramDefinition flags model msg effect"},{"name":"createElement","comment":" Creates a `ProgramTest` from the parts of a `Browser.element` program.\n\nSee other `create*` functions below if the program you want to test does not use `Browser.element`.\n\nIf your program has subscriptions that you want to simulate, see [`withSimulatedSubscriptions`](#withSimulatedSubscriptions).\n\n","type":"{ init : flags -> ( model, effect ), view : model -> Html.Html msg, update : msg -> model -> ( model, effect ) } -> ProgramTest.ProgramDefinition flags model msg effect"},{"name":"createFailed","comment":" `createFailed` can be used to report custom errors if you are writing your own convenience functions to **create** program tests.\n\nThe parameters are:\n\n1.  The name of your helper function (displayed in failure messages)\n2.  The failure message (also included in the failure message)\n\nNOTE: if you are writing a convenience function that takes a `ProgramTest` as input, you should use [`fail`](#fail) instead,\nas it provides more context in the test failure message.\n\n    -- JsonSchema and MyProgram are imaginary modules for this example\n\n\n    import JsonSchema exposing (Schema, validateJsonSchema)\n    import MyProgram exposing (Model, Msg)\n    import ProgramTest exposing (ProgramTest)\n\n    createWithValidatedJson : Schema -> String -> ProgramTest Model Msg (Cmd Msg)\n    createWithValidatedJson schema json =\n        case validateJsonSchema schema json of\n            Err message ->\n                ProgramTest.createFailed\n                    \"createWithValidatedJson\"\n                    (\"JSON schema validation failed:\\n\" ++ message)\n\n            Ok () ->\n                ProgramTest.createElement\n                    { init = MyProgram.init\n                    , update = MyProgram.update\n                    , view = MyProgram.view\n                    }\n                    |> ProgramTest.start json\n\n","type":"String.String -> String.String -> ProgramTest.ProgramTest model msg effect"},{"name":"createSandbox","comment":" Creates a `ProgramDefinition` from the parts of a `Browser.sandbox` program.\n\nSee other `create*` functions below if the program you want to test does not use `Browser.sandbox`.\n\n","type":"{ init : model, update : msg -> model -> model, view : model -> Html.Html msg } -> ProgramTest.ProgramDefinition () model msg ()"},{"name":"done","comment":" Ends a `ProgramTest`, reporting any errors that occurred.\n\nNOTE: You should prefer using a [final assertion](#final-assertions) to end your test over using `done`,\nas doing so will [make the intent of your test more clear](https://www.artima.com/weblogs/viewpost.jsp?thread=35578).\n\n","type":"ProgramTest.ProgramTest model msg effect -> Expect.Expectation"},{"name":"expectLastEffect","comment":" Makes an assertion about the last effect produced by a `ProgramTest`'s program.\n\nNOTE: If you are asserting about HTTP requests being made,\nyou should prefer the functions described in [\"Simulating HTTP responses\"](#simulating-http-responses).\n\n","type":"(effect -> Expect.Expectation) -> ProgramTest.ProgramTest model msg effect -> Expect.Expectation"},{"name":"expectModel","comment":" Make an assertion about the current state of a `ProgramTest`'s model.\n","type":"(model -> Expect.Expectation) -> ProgramTest.ProgramTest model msg effect -> Expect.Expectation"},{"name":"expectPageChange","comment":" Asserts that the program ended by navigating away to another URL.\n","type":"String.String -> ProgramTest.ProgramTest model msg effect -> Expect.Expectation"},{"name":"expectView","comment":" Makes an assertion about the current state of a `ProgramTest`'s view.\n","type":"(Test.Html.Query.Single msg -> Expect.Expectation) -> ProgramTest.ProgramTest model msg effect -> Expect.Expectation"},{"name":"expectViewHas","comment":" A simpler way to assert that a `ProgramTest`'s view matches a given selector.\n\n`expectViewHas [...selector...]` is the same as `expectView (Test.Html.Query.has [...selector...])`.\n\n","type":"List.List Test.Html.Selector.Selector -> ProgramTest.ProgramTest model msg effect -> Expect.Expectation"},{"name":"fail","comment":" `fail` can be used to report custom errors if you are writing your own convenience functions to deal with program tests.\n\nExample (this is a function that checks for a particular structure in the program's view,\nbut will also fail the ProgramTest if the `expectedCount` parameter is invalid):\n\n    expectNotificationCount : Int -> ProgramTest model msg effect -> ProgramTest model msg effect\n    expectNotificationCount expectedCount programTest =\n        if expectedCount <= 0 then\n            programTest\n                |> ProgramTest.fail \"expectNotificationCount\"\n                    (\"expectedCount must be positive, but was: \" ++ String.fromInt expectedCount)\n\n        else\n            programTest\n                |> shouldHave\n                    [ Test.Html.Selector.class \"notifications\"\n                    , Test.Html.Selector.text (toString expectedCount)\n                    ]\n\nIf you are writing a convenience function that is creating a program test, see [`createFailed`](#createFailed).\n\n","type":"String.String -> String.String -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"fillIn","comment":" Simulates replacing the text in an input field labeled with the given label.\n\n1.  The id of the input field\n    (which must match both the `id` attribute of the target `input` element,\n    and the `for` attribute of the `label` element),\n    or `\"\"` if the `<input>` is a descendant of the `<label>`.\n\n    NOTE: After [eeue56/elm-html-test#52](https://github.com/eeue56/elm-html-test/issues/52) is resolved,\n    a future release of this package will remove this parameter.\n\n2.  The label text of the input field.\n\n3.  The text that will entered into the input field.\n\nThere are a few different ways to accessibly label your input fields so that `fillIn` will find them:\n\n  - You can place the `<input>` element inside a `<label>` element that also contains the label text.\n\n    ```html\n    <label>\n        Favorite fruit\n        <input>\n    </label>\n    ```\n\n  - You can place the `<input>` and a `<label>` element anywhere on the page and link them with a unique id.\n\n    ```html\n    <label for=\"fruit\">Favorite fruit</label>\n    <input id=\"fruit\"></input>\n    ```\n\n  - You can use the `aria-label` attribute.\n\n    ```html\n    <input aria-label=\"Favorite fruit\"></input>\n    ```\n\nIf you need to target a `<textarea>` that does not have a label,\nsee [`fillInTextarea`](#fillInTextArea).\n\nIf you need more control over the finding the target element or creating the simulated event,\nsee [`simulate`](#simulate).\n\n","type":"String.String -> String.String -> String.String -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"fillInTextarea","comment":" Simulates replacing the text in a `<textarea>`.\n\nThis function expects that there is only one `<textarea>` in the view.\nIf your view has more than one `<textarea>`,\nprefer adding associated `<label>` elements and use [`fillIn`](#fillIn).\nIf you cannot add `<label>` elements see [`within`](#within).\n\nIf you need more control over the finding the target element or creating the simulated event,\nsee [`simulate`](#simulate).\n\n","type":"String.String -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"routeChange","comment":" Simulates a route change event (which would happen when your program is\na `Browser.application` and the user changes the URL in the browser's URL bar.\n\nThe parameter may be an absolute URL or relative URL.\n\n","type":"String.String -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"selectOption","comment":" Simulates choosing an option with the given text in a select with a given label\n\nThe parameters are:\n\n1.  The id of the `<select>`\n    (which must match both the `id` attribute of the target `select` element,\n    and the `for` attribute of the `label` element),\n    or `\"\"` if the `<select>` is a descendant of the `<label>`.\n\n    NOTE: After [eeue56/elm-html-test#52](https://github.com/eeue56/elm-html-test/issues/52) is resolved,\n    a future release of this package will remove this parameter.\n\n2.  The label text of the select.\n\n3.  The `value` of the `<option>` that will be chosen.\n\n    NOTE: After [eeue56/elm-html-test#51](https://github.com/eeue56/elm-html-test/issues/51) is resolved,\n    a future release of this package will remove this parameter.\n\n4.  The user-visible text of the `<option>` that will be chosen.\n\nExample: If you have a view like the following,\n\n    import Html\n    import Html.Attributes exposing (for, id, value)\n    import Html.Events exposing (on, targetValue)\n\n    Html.div []\n        [ Html.label [ for \"pet-select\" ] [ Html.text \"Choose a pet\" ]\n        , Html.select\n            [ id \"pet-select\", on \"change\" targetValue ]\n            [ Html.option [ value \"dog\" ] [ Html.text \"Dog\" ]\n            , Html.option [ value \"hamster\" ] [ Html.text \"Hamster\" ]\n            ]\n        ]\n\nyou can simulate selecting an option like this:\n\n    ProgramTest.selectOption \"pet-select\" \"Choose a pet\" \"dog\" \"Dog\"\n\nIf you need more control over the finding the target element or creating the simulated event,\nsee [`simulate`](#simulate).\n\n","type":"String.String -> String.String -> String.String -> String.String -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"shouldHave","comment":" `shouldHave [...selector...]` is equivalent to `shouldHaveView (Test.Html.Query.has [...selector...])`\n","type":"List.List Test.Html.Selector.Selector -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"shouldHaveLastEffect","comment":" Validates the last effect produced by a `ProgramTest`'s program without ending the `ProgramTest`.\n\nNOTE: If you are asserting about HTTP requests being made,\nyou should prefer the functions described in [\"Simulating HTTP responses\"](#simulating-http-responses).\n\n","type":"(effect -> Expect.Expectation) -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"shouldHaveView","comment":" Validates the the current state of a `ProgramTest`'s view without ending the `ProgramTest`.\n","type":"(Test.Html.Query.Single msg -> Expect.Expectation) -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"shouldNotHave","comment":" `shouldNotHave [...selector...]` is equivalent to `shouldHaveView (Test.Html.Query.hasNot [...selector...])`\n","type":"List.List Test.Html.Selector.Selector -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"simulate","comment":" Simulates a custom DOM event.\n\nNOTE: If there is another, more specific function (see [Simulating user input](#simulating-user-input)\nthat does what you want, prefer that instead, as you will get the benefit of better error messages.\n\nParameters:\n\n  - `findTarget`: A function to find the HTML element that responds to the event\n    (typically this will be a call to `Test.Html.Query.find [ ...some selector... ]`)\n  - `( eventName, eventValue )`: The event to simulate\n    (see [Test.Html.Event \"Event Builders\"](http://package.elm-lang.org/packages/eeue56/elm-html-test/latest/Test-Html-Event#event-builders))\n\n","type":"(Test.Html.Query.Single msg -> Test.Html.Query.Single msg) -> ( String.String, Json.Encode.Value ) -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"simulateHttpOk","comment":" Simulates an HTTP 200 response to a pending request with the given method and url.\n\n    ...\n        |> simulateHttpOk \"GET\"\n            \"https://example.com/time.json\"\n            \"\"\"{\"currentTime\":1559013158}\"\"\"\n        |> ...\n\nIf you need to simulate an error, a response with a different status code,\nor a response with response headers,\nsee [`simulateHttpResponse`](#simulateHttpResponse).\n\nIf you want to check the request headers or request body, use [`assertHttpRequest`](#assertHttpRequest)\nimmediately before using `simulateHttpOk`.\n\nNOTE: You must use [`withSimulatedEffects`](#withSimulatedEffects) before you call [`start`](#start) to be able to use this function.\n\n","type":"String.String -> String.String -> String.String -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"simulateHttpResponse","comment":" Simulates a response to a pending HTTP request.\nThe test will fail if there is no pending request matching the given method and url.\n\nYou may find it helpful to see the [\"Responses\" section in `Test.Http`](Test-Http#responses)\nfor convenient ways to create `Http.Response` values.\n\nIf you are simulating a 200 OK response and don't need to provide response headers,\nyou can use the simpler [`simulateHttpOk`](#simulateHttpOk).\n\nIf you want to check the request headers or request body, use [`assertHttpRequest`](#assertHttpRequest)\nimmediately before using `simulateHttpResponse`.\n\nNOTE: You must use [`withSimulatedEffects`](#withSimulatedEffects) before you call [`start`](#start) to be able to use this function.\n\n","type":"String.String -> String.String -> Http.Response String.String -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"simulateIncomingPort","comment":" Lets you simulate a value being received on an incoming port.\n\nThe parameters are:\n\n1.  The name of the port\n2.  The JSON representation of the incoming value\n\nNOTE: You must use [`withSimulatedSubscriptions`](#withSimulatedSubscriptions) before you call [`start`](#start) to be able to use this function.\n\n","type":"String.String -> Json.Encode.Value -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"simulateLastEffect","comment":" Simulate the outcome of the last effect produced by the program being tested\nby providing a function that can convert the last effect into `msg`s.\n\nThe function you provide will be called with the effect that was returned by the most recent call to `update` or `init` in the `ProgramTest`.\n\n  - If it returns `Err`, then that will cause the `ProgramTest` to enter a failure state with the provided message.\n  - If it returns `Ok`, then the list of `msg`s will be applied in order via `ProgramTest.update`.\n\nNOTE: If you are simulating HTTP response, you should prefer the functions described in [\"Simulating HTTP responses\"](#simulating-http-responses).\n\n","type":"(effect -> Result.Result String.String (List.List msg)) -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"start","comment":" Starts the given test program by initializing it with the given flags.\n\nIf your program uses `Json.Encode.Value` as its flags type,\nyou may find [`withJsonStringFlags`](#withJsonStringFlags) useful.\n\n","type":"flags -> ProgramTest.ProgramDefinition flags model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"update","comment":" Advances the state of the `ProgramTest` by applying the given `msg` to your program's update function\n(provided when you created the `ProgramTest`).\n\nThis can be used to simulate events that can only be triggered by [commands (`Cmd`) and subscriptions (`Sub`)](https://guide.elm-lang.org/architecture/effects/)\n(i.e., that cannot be triggered by user interaction with the view).\n\nNOTE: When possible, you should prefer [Simulating user input](#simulating-user-input),\n[Simulating HTTP responses](#simulating-http-responses),\nor (if neither of those support what you need) [`simulateLastEffect`](#simulateLastEffect),\nas doing so will make your tests more robust to changes in your program's implementation details.\n\n","type":"msg -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"},{"name":"withBaseUrl","comment":" Sets the initial browser URL\n\nYou must set this when using `createApplication`,\nor when using [`clickLink`](#clickLink) and [`expectPageChange`](#expectPageChange)\nto simulate a user clicking a link with relative URL.\n\n","type":"String.String -> ProgramTest.ProgramDefinition flags model msg effect -> ProgramTest.ProgramDefinition flags model msg effect"},{"name":"withJsonStringFlags","comment":" Provides a convenient way to provide flags for a program that decodes flags from JSON.\nBy providing the JSON decoder, you can then provide the flags as a JSON string when calling\n[`start`](#start).\n","type":"Json.Decode.Decoder flags -> ProgramTest.ProgramDefinition flags model msg effect -> ProgramTest.ProgramDefinition String.String model msg effect"},{"name":"withSimulatedEffects","comment":" This allows you to provide a function that lets `ProgramTest` simulate effects that would become `Cmd`s and `Task`s\nwhen your app runs in production\n(this enables you to use [`simulateHttpResponse`](#simulateHttpResponse), [`advanceTime`](#advanceTime), etc.).\n\nYou only need to use this if you need to [simulate HTTP requests](#simulating-http-responses)\nor the [passing of time](#simulating-time).\n\nSee the `SimulatedEffect.*` modules in this package for functions that you can use to implement\nthe required `effect -> SimulatedEffect msg` function for your `effect` type.\n\n","type":"(effect -> ProgramTest.SimulatedEffect msg) -> ProgramTest.ProgramDefinition flags model msg effect -> ProgramTest.ProgramDefinition flags model msg effect"},{"name":"withSimulatedSubscriptions","comment":" This allows you to provide a function that lets `ProgramTest` simulate subscriptions that would be `Sub`s\nwhen your app runs in production\n(this enables you to use [`simulateIncomingPort`](#simulateIncomingPort), etc.).\n\nYou only need to use this if you need to simulate subscriptions in your test.\n\nThe function you provide should be similar to your program's `subscriptions` function\nbut return `SimulatedSub`s instead of `Sub`s.\nSee the `SimulatedEffect.*` modules in this package for functions that you can use to implement\nthe required `model -> SimulatedSub msg` function.\n\n","type":"(model -> ProgramTest.SimulatedSub msg) -> ProgramTest.ProgramDefinition flags model msg effect -> ProgramTest.ProgramDefinition flags model msg effect"},{"name":"within","comment":" Focus on a part of the view for a particular operation.\n\nFor example, if your view produces the following HTML:\n\n```html\n<div>\n  <div id=\"sidebar\">\n    <button>Submit</button>\n  </div>\n  <div id=\"content\">\n    <button>Submit</button>\n  </div>\n</div>\n```\n\nthen the following will allow you to simulate clicking the \"Submit\" button in the sidebar\n(simply using `clickButton \"Submit\"` would fail because there are two buttons matching that text):\n\n    import Test.Html.Query as Query\n    import Test.Html.Selector exposing (id)\n\n    programTest\n        |> ProgramTest.within\n            (Query.find [ id \"sidebar\" ])\n            (ProgramTest.clickButton \"Submit\")\n        |> ...\n\n","type":"(Test.Html.Query.Single msg -> Test.Html.Query.Single msg) -> (ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect) -> ProgramTest.ProgramTest model msg effect -> ProgramTest.ProgramTest model msg effect"}],"binops":[]},{"name":"SimulatedEffect.Cmd","comment":" This module parallels [elm/core's `Platform.Cmd` module](https://package.elm-lang.org/packages/elm/core/1.0.2/Platform-Cmd).\n\nThe functions here produce `SimulatedEffect`s instead of `Cmd`s, which are meant to be used\nto help you implement the function to provide when using [`ProgramTest.withSimulatedEffects`](ProgramTest#withSimulatedEffects).\n\n@docs none, batch\n\n@docs map\n\n","unions":[],"aliases":[],"values":[{"name":"batch","comment":" When you need the runtime system to perform a couple commands, you can batch them together.\n","type":"List.List (SimulatedEffect.SimulatedEffect msg) -> SimulatedEffect.SimulatedEffect msg"},{"name":"map","comment":" Transform the messages produced by a command.\n","type":"(a -> msg) -> SimulatedEffect.SimulatedEffect a -> SimulatedEffect.SimulatedEffect msg"},{"name":"none","comment":" Tell the runtime that there are no commands.\n","type":"SimulatedEffect.SimulatedEffect msg"}],"binops":[]},{"name":"SimulatedEffect.Http","comment":" This module parallels [elm/http's `Http` module](https://package.elm-lang.org/packages/elm/http/2.0.0/Http).\nPRs are welcome to add any functions that are missing.\n\nThe functions here produce `SimulatedEffect`s instead of `Cmd`s, which are meant to be used\nto help you implement the function to provide when using [`ProgramTest.withSimulatedEffects`](ProgramTest#withSimulatedEffects).\n\n\n# Requests\n\n@docs get, post, request\n\n\n# Header\n\n@docs Header, header\n\n\n# Body\n\n@docs Body, emptyBody, stringBody, jsonBody\n\n\n# Expect\n\n@docs Expect, expectString, expectJson, expectWhatever, Error\n\n\n# Elaborate Expectations\n\n@docs Response\n\n\n# Tasks\n\n@docs task, Resolver, stringResolver\n\n","unions":[{"name":"Body","comment":" Represents the body of a `Request`.\n","args":[],"cases":[]},{"name":"Expect","comment":" Logic for interpreting a response body.\n","args":["msg"],"cases":[]},{"name":"Resolver","comment":" Describes how to resolve an HTTP task.\n","args":["x","a"],"cases":[]}],"aliases":[{"name":"Error","comment":" ","args":[],"type":"Http.Error"},{"name":"Header","comment":" An HTTP header for configuring requests.\n","args":[],"type":"( String.String, String.String )"},{"name":"Response","comment":" ","args":["body"],"type":"Http.Response body"}],"values":[{"name":"emptyBody","comment":" Create an empty body for your `Request`.\n","type":"SimulatedEffect.Http.Body"},{"name":"expectJson","comment":" Expect the response body to be JSON.\n","type":"(Result.Result Http.Error a -> msg) -> Json.Decode.Decoder a -> SimulatedEffect.Http.Expect msg"},{"name":"expectString","comment":" Expect the response body to be a `String`.\n","type":"(Result.Result Http.Error String.String -> msg) -> SimulatedEffect.Http.Expect msg"},{"name":"expectWhatever","comment":" Expect the response body to be whatever.\n","type":"(Result.Result SimulatedEffect.Http.Error () -> msg) -> SimulatedEffect.Http.Expect msg"},{"name":"get","comment":" Create a `GET` request.\n","type":"{ url : String.String, expect : SimulatedEffect.Http.Expect msg } -> SimulatedEffect.SimulatedEffect msg"},{"name":"header","comment":" Create a `Header`.\n","type":"String.String -> String.String -> SimulatedEffect.Http.Header"},{"name":"jsonBody","comment":" Put some JSON value in the body of your `Request`. This will automatically\nadd the `Content-Type: application/json` header.\n","type":"Json.Encode.Value -> SimulatedEffect.Http.Body"},{"name":"post","comment":" Create a `POST` request.\n","type":"{ url : String.String, body : SimulatedEffect.Http.Body, expect : SimulatedEffect.Http.Expect msg } -> SimulatedEffect.SimulatedEffect msg"},{"name":"request","comment":" Create a custom request.\n","type":"{ method : String.String, headers : List.List SimulatedEffect.Http.Header, url : String.String, body : SimulatedEffect.Http.Body, expect : SimulatedEffect.Http.Expect msg, timeout : Maybe.Maybe Basics.Float, tracker : Maybe.Maybe String.String } -> SimulatedEffect.SimulatedEffect msg"},{"name":"stringBody","comment":" Put some string in the body of your `Request`.\n","type":"String.String -> String.String -> SimulatedEffect.Http.Body"},{"name":"stringResolver","comment":" Turn a response with a `String` body into a result.\n","type":"(SimulatedEffect.Http.Response String.String -> Result.Result x a) -> SimulatedEffect.Http.Resolver x a"},{"name":"task","comment":" Just like [`request`](#request), but it creates a `Task`.\n","type":"{ method : String.String, headers : List.List SimulatedEffect.Http.Header, url : String.String, body : SimulatedEffect.Http.Body, resolver : SimulatedEffect.Http.Resolver x a, timeout : Maybe.Maybe Basics.Float } -> SimulatedEffect.SimulatedTask x a"}],"binops":[]},{"name":"SimulatedEffect.Navigation","comment":" This module parallels [elm/browsers's `Browser.Navigation` module](https://package.elm-lang.org/packages/elm/browser/1.0.1/Browser-Navigation).\nPRs are welcome to add any functions that are missing.\n\nThe functions here produce `SimulatedEffect`s instead of `Cmd`s, which are meant to be used\nto help you implement the function to provide when using [`ProgramTest.withSimulatedEffects`](ProgramTest#withSimulatedEffects).\n\n\n# Navigate within Page\n\n@docs pushUrl, replaceUrl\n\n","unions":[],"aliases":[],"values":[{"name":"pushUrl","comment":" Change the URL, but do not trigger a page load.\nThis will add a new entry to the browser history.\n","type":"String.String -> SimulatedEffect.SimulatedEffect msg"},{"name":"replaceUrl","comment":" Change the URL, but do not trigger a page load.\nThis _will not_ add a new entry to the browser history.\n","type":"String.String -> SimulatedEffect.SimulatedEffect msg"}],"binops":[]},{"name":"SimulatedEffect.Ports","comment":" This module provides functions that allow you to create `SimulatedEffect`s\nthat parallel [Elm ports](https://guide.elm-lang.org/interop/ports.html) used in your real program.\nThis is meant to be used\nto help you implement the function to provide when using\n[`ProgramTest.withSimulatedEffects`](ProgramTest#withSimulatedEffects)\nand [`ProgramTest.withSimulatedSubscriptions`](ProgramTest#withSimulatedSubscriptions).\n\n@docs send, subscribe\n\n","unions":[],"aliases":[],"values":[{"name":"send","comment":" Creates a `SimulatedEffect` that parallels using an outgoing Elm port.\n\nFor example, if your production code uses a port like this:\n\n    port logMessage : String -> Cmd msg\n\n    logMessage \"hello\"\n\nThen the corresponding `SimulatedEffect` would be:\n\n    SimulatedEffect.Ports.send \"logMessage\" (Json.Encode.string \"hello\")\n\n","type":"String.String -> Json.Encode.Value -> SimulatedEffect.SimulatedEffect msg"},{"name":"subscribe","comment":" Creates a `SimulatedSub` that parallels using an incoming Elm port.\n\nFor example, if your production code uses a port like this:\n\n    port activeUsers : (List String -> msg) -> Sub msg\n\n    subscriptions : Model -> Sub Msg\n    subscriptions model =\n        activeUsers OnActiveUsersLoaded\n\nThen the corresponding `SimulatedSub` would be:\n\n    simulatedSubscriptions : Model -> SimulatedSub Msg\n    simulatedSubscriptions model =\n        SimulatedEffect.Ports.subscribe\n            \"activeUsers\"\n            (Json.Decode.list Json.Decode.string)\n            OnActiveUsersLoaded\n\n","type":"String.String -> Json.Decode.Decoder a -> (a -> msg) -> SimulatedEffect.SimulatedSub msg"}],"binops":[]},{"name":"SimulatedEffect.Process","comment":" This module parallels [elm/core's `Process` module](https://package.elm-lang.org/packages/elm/core/1.0.2/Process).\nPRs are welcome to add any functions that are missing.\n\nThe functions here produce `SimulatedEffect`s instead of `Cmd`s, which are meant to be used\nto help you implement the function to provide when using [`ProgramTest.withSimulatedEffects`](ProgramTest#withSimulatedEffects).\n\n\n# Processes\n\n@docs sleep\n\n","unions":[],"aliases":[],"values":[{"name":"sleep","comment":" Block progress on the current process for the given number of milliseconds.\n","type":"Basics.Float -> SimulatedEffect.SimulatedTask x ()"}],"binops":[]},{"name":"SimulatedEffect.Sub","comment":" This module parallels [elm/core's `Platform.Sub` module](https://package.elm-lang.org/packages/elm/core/1.0.2/Platform-Sub).\n\nThe functions here produce `SimulatedSub`s instead of `Sub`s, which are meant to be used\nto help you implement the function to provide when using [`ProgramTest.withSimulatedSubscriptions`](ProgramTest#withSimulatedSubscriptions).\n\n@docs none, batch\n\n@docs map\n\n","unions":[],"aliases":[],"values":[{"name":"batch","comment":" When you need to subscribe to multiple things, you can create a `batch` of subscriptions.\n","type":"List.List (SimulatedEffect.SimulatedSub msg) -> SimulatedEffect.SimulatedSub msg"},{"name":"map","comment":" Transform the messages produced by a subscription.\n","type":"(a -> msg) -> SimulatedEffect.SimulatedSub a -> SimulatedEffect.SimulatedSub msg"},{"name":"none","comment":" Tell the runtime that there are no subscriptions.\n","type":"SimulatedEffect.SimulatedSub msg"}],"binops":[]},{"name":"SimulatedEffect.Task","comment":" This module parallels [elm/core's `Task` module](https://package.elm-lang.org/packages/elm/core/1.0.2/Task).\nPRs are welcome to add any functions that are missing.\n\nThe functions here produce `SimulatedTasks`s instead of `Tasks`s\nand `SimulatedEffect`s instead of `Cmd`s, which are meant to be used\nto help you implement the function to provide when using [`ProgramTest.withSimulatedEffects`](ProgramTest#withSimulatedEffects).\n\n\n# Tasks\n\n@docs perform, attempt\n\n\n# Chains\n\n@docs andThen, succeed, fail\n\n\n# Maps\n\n@docs map\n\n\n# Errors\n\n@docs mapError\n\n","unions":[],"aliases":[],"values":[{"name":"andThen","comment":" Chain together a task and a callback.\n","type":"(a -> SimulatedEffect.SimulatedTask x b) -> SimulatedEffect.SimulatedTask x a -> SimulatedEffect.SimulatedTask x b"},{"name":"attempt","comment":" This is very similar to [`perform`](#perform) except it can handle failures!\n","type":"(Result.Result x a -> msg) -> SimulatedEffect.SimulatedTask x a -> SimulatedEffect.SimulatedEffect msg"},{"name":"fail","comment":" A task that fails immediately when run.\n","type":"x -> SimulatedEffect.SimulatedTask x a"},{"name":"map","comment":" Transform a task.\n","type":"(a -> b) -> SimulatedEffect.SimulatedTask x a -> SimulatedEffect.SimulatedTask x b"},{"name":"mapError","comment":" Transform the error value.\n","type":"(x -> y) -> SimulatedEffect.SimulatedTask x a -> SimulatedEffect.SimulatedTask y a"},{"name":"perform","comment":" ","type":"(a -> msg) -> SimulatedEffect.SimulatedTask Basics.Never a -> SimulatedEffect.SimulatedEffect msg"},{"name":"succeed","comment":" A task that succeeds immediately when run.\n","type":"a -> SimulatedEffect.SimulatedTask x a"}],"binops":[]},{"name":"Test.Http","comment":" Convenience functions for testing HTTP requests.\n\n\n## Expectations\n\n@docs expectJsonBody, hasHeader\n\n\n## Responses\n\nThese are ways to easily make `Http.Response` values for use with [`ProgramTest.simulateHttpResponse`](ProgramTest#simulateHttpResponse).\n\n@docs timeout, networkError, httpResponse\n\n","unions":[],"aliases":[],"values":[{"name":"expectJsonBody","comment":" A convenient way to check something about the request body of a pending HTTP request.\n\n    ...\n        |> ProgramTest.assertHttpRequest \"POST\"\n            \"https://example.com/ok\"\n            (Test.Http.expectJsonBody\n                (Json.Decode.field \"version\" Json.Decode.string)\n                (Expect.equal \"3.1.5\")\n            )\n        |> ...\n\n","type":"Json.Decode.Decoder requestBody -> (requestBody -> Expect.Expectation) -> SimulatedEffect.HttpRequest x a -> Expect.Expectation"},{"name":"hasHeader","comment":" Assert that the given HTTP request has the specified header.\n\n    ...\n        |> ProgramTest.assertHttpRequest \"POST\"\n            \"https://example.com/ok\"\n            (Test.Http.hasHeader \"Content-Type\" \"application/json\")\n        |> ...\n\n","type":"String.String -> String.String -> SimulatedEffect.HttpRequest x a -> Expect.Expectation"},{"name":"httpResponse","comment":" This is a more convenient way to create `Http.BadStatus_` and `Http.GoodStatus_` values.\n\nFollowing the [logic in elm/http](https://github.com/elm/http/blob/2.0.0/src/Elm/Kernel/Http.js#L65),\nthis will produce `Http.GoodStatus_` if the given status code is in the 200 series, otherwise\nit will produce `Http.BadStatus_`.\n\n","type":"{ statusCode : Basics.Int, headers : List.List ( String.String, String.String ), body : body } -> Http.Response body"},{"name":"networkError","comment":" This is the same as `Http.NetworkError_`,\nbut is exposed here so that your test doesn't need to import both `Http` and `Test.Http`.\n","type":"Http.Response body"},{"name":"timeout","comment":" This is the same as `Http.Timeout_`,\nbut is exposed here so that your test doesn't need to import both `Http` and `Test.Http`.\n","type":"Http.Response body"}],"binops":[]}]